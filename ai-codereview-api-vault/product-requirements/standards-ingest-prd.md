# Standards Ingest Product Requirements Document (PRD)

## 1. Executive Summary

We are extending an existing code review system to support ingestion and management of multiple standards sets—collections of individual standards—for code quality checks. The system will allow users to:

1. Upload and manage **Standards Sets** and **Tags** (metadata about technologies/languages)
2. Dynamically match code repositories against the standards relevant to the repository's technology stack
3. Provide integrated **frontend pages** and **backend API endpoints** for managing standards, tags, and code reviews

These features build on an existing Python-based API (FastAPI) that leverages Anthropic's Claude AI model and MongoDB for persistence, and a Node.js/Hapi.js-based GOV.UK Design System (GDS)-compliant frontend.

## 2. Background

### 2.1 Existing System Overview

#### 2.1.1 Core Functionality (Current)
* **Accept Code Submissions** for review
* **Process submissions asynchronously** using AI agents
* **Check code against multiple predefined standards**
* **Store review results** in MongoDB
* **Provide RESTful API endpoints** to retrieve and manage code review results

Currently, the system is configured with a **hard-coded** set of standards.

#### 2.1.2 API Backend
* **Language/Framework**: Python, FastAPI
* **AI Model**: Anthropic's Claude for intelligent code analysis
* **Database**: MongoDB for persistence
* **Architecture**:
  * Modular structure with FastAPI's dependency injection
  * Robust logging, strict typing, and comprehensive tests
  * Enforces code quality with Pylint and Pyright

#### 2.1.3 Frontend
* **Language/Framework**: Node.js with Hapi.js
* **Design**: GOV.UK Design System (GDS) with SCSS for styling
* **Rendering**: Nunjucks templating, server-side rendering
* **Tooling**: Webpack, Babel, TypeScript, Jest, ESLint, Prettier
* **Current Features**:
  * A home page for repository submission
  * Health check endpoints
  * Error handling pages
  * Basic routing for future expansion

## 3. Problem Statement & Goals

### 3.1 Problem Statement

* Currently, the code review system only supports a single, hard-coded set of standards
* We need the ability to ingest **any** standards from remote repositories and store them in the database
* We must implement a **Tag Manager** to match code repositories with relevant standards based on technology stacks

### 3.2 Goals

1. **Flexible Standards Ingestion**: Allow users to upload new standard sets and automatically parse them into individual standards
2. **Tag-Based Matching**: Implement a tag system to label standards (e.g., "Python," "Node.js," ".NET") and automatically match code repositories to relevant standards
3. **Enhanced Reporting**: Adapt the existing code review process to incorporate multiple standard sets, each with its own custom LLM prompt
4. **Frontend Management**: Provide user interfaces to manage tags, standards, and standard sets in alignment with GDS guidelines

## 4. High-Level Solution Overview

1. **Tag Manager**
   * Backend to manage tags (create, list, delete)
   * Frontend pages to create/delete tags
   * Allows grouping of technologies/languages in code repositories

2. **Standards Ingest**
   * Ingest a "standards repository" from a user-provided URL
   * Parse the repository using an LLM agent, create or replace a "standard-set," and store individual "standards" in the database
   * Each standard can be associated with zero or more tags

3. **Updated Code Review Flow**
   * On code review submission, the system downloads the repository, merges the code, and uses an LLM to identify which tags apply to the codebase
   * Based on the tags that match the codebase stack, the system filters relevant standards from each selected standard set
   * The relevant standards are then passed to the reporting agent for analysis

4. **Frontend Enhancements**
   * New pages to manage standard sets and tags
   * Modified home page to show multiple standard sets for selection
   * Code review detail pages that tabulate reports by standard set

## 5. Detailed Requirements

### 5.1 Tag Manager

#### 5.1.1 Backend Requirements
1. **Database Schema**
   * New collection/table: `tags`
   * Each `tag` record includes:
     * `_id` (automatically generated by MongoDB)
     * `name` (string, unique)

2. **API Endpoints** (`/api/v1/tags`):
   * **POST** `/api/v1/tags`
     * Creates a new tag in the database
     * Request Body:
       ```json
       {
         "name": "Node.js"
       }
       ```
     * Response:
       ```json
       {
         "_id": "auto-generated-id",
         "name": "Node.js"
       }
       ```
   * **GET** `/api/v1/tags`
     * Returns all tags in alphabetical order
   * **DELETE** `/api/v1/tags/{id}`
     * Deletes the specified tag
     * Must also remove any references to this tag from any "standards" documents

#### 5.1.2 Frontend Requirements
1. **New Navigation Item**: "Manage Tags"
2. **Manage Tags Page**
   * **List** all existing tags (table view)
   * **Add** a new tag (form that calls `POST /api/v1/tags`)
   * **Delete** a tag (action that calls `DELETE /api/v1/tags/{id}`)
   * Show a **warning** message that adding or deleting tags requires re-ingestion of existing standard sets to update tagging relationships

#### 5.1.3 Example Tags
```
Python, C#, Node.js, JavaScript, Java, .NET
```

### 5.2 Standards Ingest

#### 5.2.1 Terminology
* **Code Repository**: The repository to be reviewed
* **Standard-Set**: A parent object that groups multiple individual standards. Contains:
  * `_id`, `name`, `repository_url`, `custom_prompt`
* **Standards**: Individual entries within a standard-set. Contains:
  * `_id`, `text`, `repository_path`, relation to `tags`
* **Tags**: Technology identifiers that help categorize standards (e.g., `Python`)

#### 5.2.2 Backend Requirements
1. **Database Schema**
   * **Standard-Sets** Collection
     * `_id`, `name`, `repository_url`, `custom_prompt`
   * **Standards** Collection
     * `_id`, `text`, `repository_path`, `standard_set_id`, `tags[]`

2. **Relationships**
   * **One-to-Many**: One standard-set to many standards
   * **Many-to-Many**: Many standards to many tags (implemented by storing tag IDs in the `tags[]` array within the standard document)

3. **API Endpoints**
   * **`/api/v1/standard-sets`**
     * **POST** `/api/v1/standard-sets`
       1. Check if a standard-set with the same `name` exists. If so, delete the existing one and all its associated standards
       2. Create a new standard-set record
       3. Download the repository from the provided `repository_url` to a temporary folder (note that we already have a `git_repos_agent` that can download a repository)
       4. Parse each file in the repository using an LLM agent
       5. For each discovered standard (could be multiple standards within a file), create a new record in the `standards` collection, associating it with the newly created standard-set
         * Determine relevant tags from the text (using LLM or other rules)
         * If no tags apply, the standard is universal
       6. Cleanup temporary folder
       7. Return newly created standard-set with its `_id`
     * **GET** `/api/v1/standard-sets`
       * Returns a list of standard-set objects (without their associated standards)
     * **GET** `/api/v1/standard-sets/{id}`
       * Returns one standard-set object including an array of all associated standards
     * **DELETE** `/api/v1/standard-sets/{id}`
       * Deletes the standard-set and all associated standards (and their references to tags)

### 5.3 Updated Code Review Flow

#### 5.3.1 Required Changes to Existing `/api/v1/code-reviews` Endpoint

1. **Request Payload**
   * Must now include an array of standard-set IDs to specify which sets to check against
   ```json
   {
     "repository_url": "https://github.com/DEFRA/find-ffa-data-ingester",
     "standard_sets": ["xyz123", "abc123"]
   }
   ```

2. **Processing**
   1. Download and merge the code repository (existing functionality)
   2. Use a new "Standards Selection" LLM agent to determine which tags match the codebase
      * Output (example):
      ```json
      {
        "Python": false,
        "C#": false,
        "Node.js": true,
        "JavaScript": true,
        "Java": false,
        ".NET": false
      }
      ```
   3. For each `standard_set_id` in `standard_sets`, **query** for all standards in that set whose tags array is either empty (universal) or is a subset of the `true` tags from step 2
   4. Combine these relevant standards with the code repository's merged file and pass them to the existing reporting agent
   5. Use the `custom_prompt` from the standard-set for the LLM prompt
   6. Save a separate Markdown report file per standard-set in the format:
      ```
      {code-review-record-id}-{standard-set-name}.md
      ```
   7. Store references to these new report files in the `code-reviews` record

3. **Response & Storage**
   * When the code review is complete, the `GET /api/v1/code-reviews/{id}` endpoint should provide:
     * The array of associated standard-sets used in the review
     * The Markdown reports generated for each standard-set (filename and content)

#### 5.3.2 Existing Functionality to Remove
* **Remove** hard-coded standards download in the code review flow. Standards are now **persisted** in the database

## 6. Frontend Requirements

### 6.1 Navigation
* **Manage tags**: New item linking to `/tags`
* **Manage standards**: New item linking to `/standard-sets`

### 6.2 Tag Manager Pages
* **Manage Tags Page (`/tags`)**
  * Display a **table** of all tags from `GET /api/v1/tags`
	  * **Delete Tag** button for each row of the table (DELETE to `/api/v1/tags/{id}`)
  * **Add Tag** form (POST to `/api/v1/tags`)
  * Display **warning** about re-ingestion for changes in tags

### 6.3 Standards Management

1. **Manage Standards Page (`/standard-sets`)**
   * Display a **table** of all standard-sets (from `GET /api/v1/standard-sets`)
     * Columns: Standard-Set Name, Repository URL (opens in new tab), Delete button
     * **Delete** calls `DELETE /api/v1/standard-sets/{id}`
   * **Add New Standard-Set** button -> `/standard-sets/new`

2. **Add New Standard-Set Page (`/standard-sets/new`)**
   * Form fields: `name`, `repository_url`, `custom_prompt`
   * On submit, **POST** to `/api/v1/standard-sets`
   * If success, **redirect** to `/standard-sets/{id}` (the detail page)

3. **Standard Set Detail Page (`/standard-sets/{id}`)**
   * Query **GET** `/api/v1/standard-sets/{id}` on page load
   * Show:
     * Standard-Set Name
     * Repository URL (open in new tab)
     * **Custom Prompt** (hide behind a GDS accordion)
   * **Table** of associated standards, read-only:
     * Columns:
       * Standard Text
       * Comma-separated list of tags
       * Repository Path (opens in new tab if relevant)

### 6.4 Home Page Updates
* **Standard-Sets Checkbox List**
  * Dynamically fetched from `GET /api/v1/standard-sets`
  * The user can select one or more sets to include in their code review request
  * The form then sends an array of standard-set IDs with `repository_url` to `POST /api/v1/code-reviews`
  * Add a 'check all' link that checks all the standard-sets to be included in the code review

### 6.5 Code Review Record Detail Page Updates
* **Reports Array**
  * Each code review can now have multiple standard-set reports
  * Show the list of standard-sets used for that review in the details section
  * Populate the existing **tabbed interface** or separate tabs for each standard-set's Markdown result
  * Each tab title corresponds to the standard-set name

## 7. Data Model & ER Diagram (Conceptual)

```
┌───────────────────┐          ┌────────────────────┐
│    standard-sets  │          │      standards     │
│  _id              │◄──┐ 1..* │  _id               │
│  name             │   │      │  text              │
│  repository_url   │   │      │  repository_path   │
│  custom_prompt    │   │      │  standard_set_id   │
└───────────────────┘   │      │  tag_ids[]         │
                        │      └────────────────────┘
                        │
                        │1..* (a standard-set can have many standards)
                        │
┌───────────────────┐   │
│       tags        │   │
│  _id              │   │
│  name             │◄──┘M..N (a standard can have many tags)
└───────────────────┘
```

## 8. Database Schema for Tagging System Using References

To implement the tagging system with references in MongoDB, we'll establish a many-to-many relationship between standards and tags. This approach ensures data normalization and efficient querying.

### 8.1 Collections Overview

The system consists of two main collections:

- **Tags Collection:** Stores individual tags.
- **Standards Collection:** Stores individual standards, each containing references to associated tags.

### 8.2 Tags Collection Schema

Each document in the `tags` collection represents a unique tag with the following fields:

```json
{
    "_id": ObjectId,    // Unique identifier for the tag
    "name": String      // Name of the tag (e.g., "Python", "Node.js")
}
```

### 8.3 Standards Collection Schema

Each document in the `standards` collection represents an individual standard and includes references to associated tags:

```json
{
    "_id": ObjectId,            // Unique identifier for the standard
    "text": String,            // Content of the standard
    "repository_path": String,  // Path to the standard in the repository
    "standard_set_id": ObjectId, // Reference to the associated standard-set
    "tag_ids": [ObjectId, ...]  // Array of ObjectId references to associated tags
}
```

### 8.4 Indexing Strategy

To optimize query performance, especially for operations involving tag associations, implement the following indexes:

#### Tags Collection

```json
{ "name": 1 }
```

This index ensures efficient retrieval of tags by name and enforces uniqueness if required.

#### Standards Collection

```json
{ "standard_set_id": 1 }
```

This index facilitates quick access to standards within a specific standard set.

```json
{ "tag_ids": 1 }
```

This index enables efficient querying of standards associated with specific tags.

### 8.5 Handling Tag Deletions

If a user deletes a tag, it must be removed from each standard that references the tag. The system should handle this dynamically by:

1. Removing the tag's ID from the `tag_ids` array in all affected standards in the `standards` collection.
2. Ensuring that standards with no remaining tags are correctly handled as universal (if applicable) or flagged for further review.
3. Logging the deletion operation for auditing purposes.

### 8.6 Example Documents

#### Tags Collection Document

```json
{
    "_id": ObjectId("60c72b2f9af1f8b5d1c8d1e1"),
    "name": "Python"
}
```

#### Standards Collection Document

```json
{
    "_id": ObjectId("60c72b3f9af1f8b5d1c8d1e2"),
    "text": "Standard content here...",
    "repository_path": "/path/to/standard",
    "standard_set_id": ObjectId("60c72b4f9af1f8b5d1c8d1e3"),
    "tag_ids": [
        ObjectId("60c72b2f9af1f8b5d1c8d1e1"),
        ObjectId("60c72b2f9af1f8b5d1c8d1e4")
    ]
}
```

### 8.7 Tag Deletion Workflow Example

1. **Tag Deletion Request:** A user issues a DELETE request for a tag (e.g., `Python`) via the `/api/v1/tags/{id}` endpoint.
    
2. **Database Update:** The system performs the following operations:
    
    - Query the `standards` collection for documents containing the tag's `_id` in their `tag_ids` array.
    - Remove the tag's `_id` from the `tag_ids` array of all matching standards.
    - Save the updated standards back to the database.
3. **Validation and Logging:**
    
    - Ensure no standards are left with inconsistent `tag_ids` arrays.
    - Log the operation, including the ID of the deleted tag and the affected standards.
4. **User Notification:**
    
    - Notify the user if any standards were affected by the deletion, and if necessary, recommend re-ingesting related standard sets to ensure consistency.

This workflow ensures that tag deletions are consistently propagated through the system, maintaining data integrity and alignment with operational requirements.